{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ECE/MAE 148: Introduction to Autonomous Vehicles Documentation is under development.","title":"Welcome to ECE/MAE 148: Introduction to Autonomous Vehicles"},{"location":"#welcome-to-ecemae-148-introduction-to-autonomous-vehicles","text":"Documentation is under development.","title":"Welcome to ECE/MAE 148: Introduction to Autonomous Vehicles"},{"location":"win23team2/","text":"Team 2 ECE/MAE 148 Final Report :wave: The Team: 2 Fast 2 Furious (Left to Right) - Elias Fang (CSE) - Ainesh Arumugam (ECE) - Matthew Merioles (ECE) - Junhao \"Michael\" Chen (MAE) \ud83d\udcdd Project Overview Mario Kart in real-life? That's basically what we did. We designed a boost system similar to those in Mario Kart, where detecting colored pieces of paper on the track can change throttle for a short period of time. Depending on the color of the \"pad\" the car drives over, it will either speed up, slow down, or stop for a few seconds, just like in the game! \ud83c\udfce Our Robot Bird's Eye Front Left Right Back Schematic \ud83c\udf44 Final Project What We Promised Must haves [X] Distinguishing different colors through the camera [X] Adjust the throttle based on the color Nice to haves [X] Have the car detect a flat piece of paper on the track (like a booster pad) [ ] Combine with lane-following algorithm Gantt Chart https://sharing.clickup.com/9010060626/g/h/8cgn7aj-87/769d44f22562beb What We Accomplished Color Detection Used OpenCV for color detection and edge tracing Used color mask algorithm to detect proportion of frame that color takes up Detected multiple colors at the same time Determined HSVs for orange, pink, and blue Demo PyVESC Connection through external webcam Different RPM values are sent through PyVesc to achieve different speed for different colors marked by different states: Blue (Boost) = speed up for 3 sec Pink (Slow)= slow down for 3 sec Orange (Stop) = stop for 3 sec Neutral (Normal) = constant rpm Blue Demo Pink Demo Orange Demo Presentation https://docs.google.com/presentation/d/1oJPRLYIKvHUXEIK9hoYpPFoFAyHuG6sE7ZrU9NQPG8g/edit?usp=sharing Code https://github.com/UCSD-ECEMAE-148/winter-2023-final-project-team-2/blob/main/MarioKart.py Possible Future Work Change the colored paper into Mario Kart items (mushroom, bananas, etc.) for the car to identify Allow the car to run autonomously on a track and still apply speed changes Race with other teams \ud83d\ude09 \ud83c\udfc1 Autonomous Laps DonkeyCar ROS2 Line Following ROS2 Lanes GNSS Additional Work Done Our team was tasked with implementing a depth feature with our contour function, using depthAI to integrate with the OAK-D Camera! Our updated code is now able to measure how far the contoured object is, measured in cm! [Depth Demo] https://www.youtube.com/watch?v=NYIz7--TpgY [Updated Code] https://github.com/UCSD-ECEMAE-148/winter-2023-final-project-team-2/blob/main/MarioKart_depth.py Acknowledgements Thanks for Professor Jack Silberman, TA Kishore Nukala, and TA Moises Lopez!","title":"Team 2"},{"location":"win23team2/#team-2-ecemae-148-final-report","text":"","title":"Team 2 ECE/MAE 148 Final Report"},{"location":"win23team2/#wave-the-team-2-fast-2-furious","text":"(Left to Right) - Elias Fang (CSE) - Ainesh Arumugam (ECE) - Matthew Merioles (ECE) - Junhao \"Michael\" Chen (MAE)","title":":wave: The Team: 2 Fast 2 Furious"},{"location":"win23team2/#project-overview","text":"Mario Kart in real-life? That's basically what we did. We designed a boost system similar to those in Mario Kart, where detecting colored pieces of paper on the track can change throttle for a short period of time. Depending on the color of the \"pad\" the car drives over, it will either speed up, slow down, or stop for a few seconds, just like in the game!","title":"\ud83d\udcdd Project Overview"},{"location":"win23team2/#our-robot","text":"","title":"\ud83c\udfce Our Robot"},{"location":"win23team2/#birds-eye","text":"","title":"Bird's Eye"},{"location":"win23team2/#front","text":"","title":"Front"},{"location":"win23team2/#left","text":"","title":"Left"},{"location":"win23team2/#right","text":"","title":"Right"},{"location":"win23team2/#back","text":"","title":"Back"},{"location":"win23team2/#schematic","text":"","title":"Schematic"},{"location":"win23team2/#final-project","text":"","title":"\ud83c\udf44 Final Project"},{"location":"win23team2/#what-we-promised","text":"","title":"What We Promised"},{"location":"win23team2/#must-haves","text":"[X] Distinguishing different colors through the camera [X] Adjust the throttle based on the color","title":"Must haves"},{"location":"win23team2/#nice-to-haves","text":"[X] Have the car detect a flat piece of paper on the track (like a booster pad) [ ] Combine with lane-following algorithm","title":"Nice to haves"},{"location":"win23team2/#gantt-chart","text":"https://sharing.clickup.com/9010060626/g/h/8cgn7aj-87/769d44f22562beb","title":"Gantt Chart"},{"location":"win23team2/#what-we-accomplished","text":"","title":"What We Accomplished"},{"location":"win23team2/#color-detection","text":"Used OpenCV for color detection and edge tracing Used color mask algorithm to detect proportion of frame that color takes up Detected multiple colors at the same time Determined HSVs for orange, pink, and blue Demo","title":"Color Detection"},{"location":"win23team2/#pyvesc","text":"Connection through external webcam Different RPM values are sent through PyVesc to achieve different speed for different colors marked by different states: Blue (Boost) = speed up for 3 sec Pink (Slow)= slow down for 3 sec Orange (Stop) = stop for 3 sec Neutral (Normal) = constant rpm Blue Demo Pink Demo Orange Demo","title":"PyVESC"},{"location":"win23team2/#presentation","text":"https://docs.google.com/presentation/d/1oJPRLYIKvHUXEIK9hoYpPFoFAyHuG6sE7ZrU9NQPG8g/edit?usp=sharing","title":"Presentation"},{"location":"win23team2/#code","text":"https://github.com/UCSD-ECEMAE-148/winter-2023-final-project-team-2/blob/main/MarioKart.py","title":"Code"},{"location":"win23team2/#possible-future-work","text":"Change the colored paper into Mario Kart items (mushroom, bananas, etc.) for the car to identify Allow the car to run autonomously on a track and still apply speed changes Race with other teams \ud83d\ude09","title":"Possible Future Work"},{"location":"win23team2/#autonomous-laps","text":"DonkeyCar ROS2 Line Following ROS2 Lanes GNSS","title":"\ud83c\udfc1 Autonomous Laps"},{"location":"win23team2/#additional-work-done","text":"Our team was tasked with implementing a depth feature with our contour function, using depthAI to integrate with the OAK-D Camera! Our updated code is now able to measure how far the contoured object is, measured in cm! [Depth Demo] https://www.youtube.com/watch?v=NYIz7--TpgY [Updated Code] https://github.com/UCSD-ECEMAE-148/winter-2023-final-project-team-2/blob/main/MarioKart_depth.py","title":"Additional Work Done"},{"location":"win23team2/#acknowledgements","text":"Thanks for Professor Jack Silberman, TA Kishore Nukala, and TA Moises Lopez!","title":"Acknowledgements"},{"location":"win23team3/","text":"Final Report for Team 3 (ECE/MAE 148) Team Members Nathaniel Barnaby - ECE Yang-Jie Qin - ECE Cheuk Hin Bryan Cheng - MAE Patrick Nguyen - MAE Project Overview Our initial final project was a combination of the usage of an IMU and GNSS to implement position tracking. An IMU is an inertial measurement unit, composing of gyros, accelerometers, and more sensors to track the movement of something. With these sensors, the car's location can be estimated off of a general initial GPS location with the addition to its movement measured by its speed, acceleration, turning, etc. This ended up being too complex for our team which resulted in little progress. We were then assigned new mini tasks which consists of using 2 of the sensors provided in our kits. The assignment was to use the OAK-D camera and the lidar separately to measure depth of both a small (0.15m) object and a larger (0.5m) object at different distances. We ended up comparing results of both objects at distances of 0.5, 1, 2, 3, and 4 meters. We would then compare the outputed values from the sensors to what the actual correspond measurment. A comparison between the accuracy of depth finding between the Oak-D camera and lidar would also be necesasry. A second task was assigned which was to output a face recognition system out of the OAK-D camera. Results For the distance measurement assignment, both the camera and lidar were able to successfully measure distance for the small the large object at the different ranges. For the camera, it was accurate at determining smaller distances, but at larger distances (3+ meters) error seemed to begin growing exponentionally. The difference between small and large objects was negligible as long as the area in which the distances were averaged fit within the object, which at further distances can start causing fluctuations with smaller objects. For the lidar, it was accurate at determining all distances with a linear or almost static amount of error. At smaller distances this was larger than the error of the camera, but at larger distances it vastly outperformed the camera due to the nature of the camera's exponential error. Additionally, the lidar had to be hand-calibrated, so with more time the error could have been lowered due to this effect. Also, since we recorded distance measurements within a range of 0.4 degrees, the measurement would be inaccurate with a smaller object at longer distances. This could be overcame by decreasing the range and waiting longer. For most scenarios the lidar seems to be the winning choice for distance measurement. While at lower distances the camera seemed to outperform the lidar, the lidar seems to be more consistent with its measurements than the camera. Additionally, the lidar offers 360 degrees of distance measurements while the camera only works in one direction. DepthAI Distance Measurement with ~0.5 m^2 Object Video Link DepthAI Distance Measurement with 0.15 m^2 Box Video Link LiDAR Distance Measurement with ~0.5 m^2 Object Video Link LiDAR Distance Measurement with 0.15 m^2 Box Video Link As for the camera face recognition, we were succesfully able to output video display which recognizes faces. This is a relatively fast responding system. It outputs the number of faces it recognizes which we tested from 0-3 faces real time. There is some error within the system as it can be innacurate thinking other shiny objects and or parts of a face are another face. It is also not limited to stationary faces as it recognizes people moving too. Face Recognition Video Link Gantt Chart Hardware: Mechanical Design \\ Camera/flashlight Mount \\ Electronics Tray \\ Front/rear Electronics Plate Offset \\ GPS Mount \\ IMU Mount \\ Jetson Case Key Mount \\ Jetson Nano Main Case \\ Lidar Tower \\ Servo Voltage Converter \\ Vesc Power Distributor Previous Designs Electronic Components \\ Jetson Nano \\ OAK-D Camera \\ Lidar LD06 Electronic Wiring Schematic Final Set Up Bird's Eye View Left View Right View Packages and Drivers cv2 (OpenCV) depthai (DepthAI) numpy math binascii Milestones Face Recognition using DepthAI - Detects faces through a webcam and displays a count in the terminal Distance Measurement using DepthAI - Using the disparity between the left and right cameras of the OAKD, distance can be calculated. This was averaged over an area to give an estimated distance of an object. Distance Measurement using LiDAR - Using a LiDAR is is relatively simple to detect distances in a 360 degree range. By averaging distances over a very small range (0.4 degrees) we determined the distance of an object. Potential Future Work/Unaccomplished Goals Recognizing and labeling specific faces Running code off of the OAK-D Camera instead of needing an external computer to run the code. Presentations - Final Project Proposal - Final Presentation Acknowledgments Professor Jack Silberman, TA Kishore Nukala, Moises Lopez-Mendoza, Design and Innovation Building, all of our wonderful classmates","title":"Team 3"},{"location":"win23team3/#final-report-for-team-3-ecemae-148","text":"","title":"Final Report for Team 3 (ECE/MAE 148)"},{"location":"win23team3/#team-members","text":"Nathaniel Barnaby - ECE Yang-Jie Qin - ECE Cheuk Hin Bryan Cheng - MAE Patrick Nguyen - MAE","title":"Team Members"},{"location":"win23team3/#project-overview","text":"Our initial final project was a combination of the usage of an IMU and GNSS to implement position tracking. An IMU is an inertial measurement unit, composing of gyros, accelerometers, and more sensors to track the movement of something. With these sensors, the car's location can be estimated off of a general initial GPS location with the addition to its movement measured by its speed, acceleration, turning, etc. This ended up being too complex for our team which resulted in little progress. We were then assigned new mini tasks which consists of using 2 of the sensors provided in our kits. The assignment was to use the OAK-D camera and the lidar separately to measure depth of both a small (0.15m) object and a larger (0.5m) object at different distances. We ended up comparing results of both objects at distances of 0.5, 1, 2, 3, and 4 meters. We would then compare the outputed values from the sensors to what the actual correspond measurment. A comparison between the accuracy of depth finding between the Oak-D camera and lidar would also be necesasry. A second task was assigned which was to output a face recognition system out of the OAK-D camera.","title":"Project Overview"},{"location":"win23team3/#results","text":"For the distance measurement assignment, both the camera and lidar were able to successfully measure distance for the small the large object at the different ranges. For the camera, it was accurate at determining smaller distances, but at larger distances (3+ meters) error seemed to begin growing exponentionally. The difference between small and large objects was negligible as long as the area in which the distances were averaged fit within the object, which at further distances can start causing fluctuations with smaller objects. For the lidar, it was accurate at determining all distances with a linear or almost static amount of error. At smaller distances this was larger than the error of the camera, but at larger distances it vastly outperformed the camera due to the nature of the camera's exponential error. Additionally, the lidar had to be hand-calibrated, so with more time the error could have been lowered due to this effect. Also, since we recorded distance measurements within a range of 0.4 degrees, the measurement would be inaccurate with a smaller object at longer distances. This could be overcame by decreasing the range and waiting longer. For most scenarios the lidar seems to be the winning choice for distance measurement. While at lower distances the camera seemed to outperform the lidar, the lidar seems to be more consistent with its measurements than the camera. Additionally, the lidar offers 360 degrees of distance measurements while the camera only works in one direction. DepthAI Distance Measurement with ~0.5 m^2 Object Video Link DepthAI Distance Measurement with 0.15 m^2 Box Video Link LiDAR Distance Measurement with ~0.5 m^2 Object Video Link LiDAR Distance Measurement with 0.15 m^2 Box Video Link As for the camera face recognition, we were succesfully able to output video display which recognizes faces. This is a relatively fast responding system. It outputs the number of faces it recognizes which we tested from 0-3 faces real time. There is some error within the system as it can be innacurate thinking other shiny objects and or parts of a face are another face. It is also not limited to stationary faces as it recognizes people moving too. Face Recognition Video Link","title":"Results"},{"location":"win23team3/#gantt-chart","text":"","title":"Gantt Chart"},{"location":"win23team3/#hardware-mechanical-design","text":"\\ Camera/flashlight Mount \\ Electronics Tray \\ Front/rear Electronics Plate Offset \\ GPS Mount \\ IMU Mount \\ Jetson Case Key Mount \\ Jetson Nano Main Case \\ Lidar Tower \\ Servo Voltage Converter \\ Vesc Power Distributor","title":"Hardware: Mechanical Design"},{"location":"win23team3/#previous-designs","text":"","title":"Previous Designs"},{"location":"win23team3/#electronic-components","text":"\\ Jetson Nano \\ OAK-D Camera \\ Lidar LD06","title":"Electronic Components"},{"location":"win23team3/#electronic-wiring-schematic","text":"","title":"Electronic Wiring Schematic"},{"location":"win23team3/#final-set-up","text":"Bird's Eye View Left View Right View","title":"Final Set Up"},{"location":"win23team3/#packages-and-drivers","text":"cv2 (OpenCV) depthai (DepthAI) numpy math binascii","title":"Packages and Drivers"},{"location":"win23team3/#milestones","text":"Face Recognition using DepthAI - Detects faces through a webcam and displays a count in the terminal Distance Measurement using DepthAI - Using the disparity between the left and right cameras of the OAKD, distance can be calculated. This was averaged over an area to give an estimated distance of an object. Distance Measurement using LiDAR - Using a LiDAR is is relatively simple to detect distances in a 360 degree range. By averaging distances over a very small range (0.4 degrees) we determined the distance of an object.","title":"Milestones"},{"location":"win23team3/#potential-future-workunaccomplished-goals","text":"Recognizing and labeling specific faces Running code off of the OAK-D Camera instead of needing an external computer to run the code.","title":"Potential Future Work/Unaccomplished Goals"},{"location":"win23team3/#presentations","text":"- Final Project Proposal - Final Presentation","title":"Presentations"},{"location":"win23team3/#acknowledgments","text":"Professor Jack Silberman, TA Kishore Nukala, Moises Lopez-Mendoza, Design and Innovation Building, all of our wonderful classmates","title":"Acknowledgments"},{"location":"win23team4/","text":"Team 4 Final Project Report Members: Vasanth Senthil (ECE), Eddy Rodas Lima(MAE), Lingpeng Meng(ECE) Physical Setup Initial Goals Objective Make our RoboCar follow sound using sound localization from multiple microphones. Must Haves Car is able to determine approximate direction of an audio source Car moves in towards audio source once direction of audio is determined Nice to Haves Car follows specific audio signals (eg. someone\u2019s voice) rather than based on volume Accurate movement towards source Accomplishments Researched and experimented with different methods of sound localization, such as using time of arrival delay between microphones Used the pyaudio library to collect streams of microphone data from each of the three microphone, and processed this data in order to tell direction real-time based on sound level Used the pyvesc library to create a custom movement file that allows us to easily move the RoboCar based on provided angles and throttle until specified conditions are met The microphone processing file called upon the movement functions after determining current direction. We also spread the left and right microphones to minimize the noise created by the car\u2019s movement, which would influence the accuracy of direction calculations. Demo Videos Static Source Left Static Source Right Moving Source Front Moving Source Back Moving Source Further Away Issues Faced Issue Solution Original idea of using time delay between microphones was not possible due to jetson limitations Decided to use volume of sound signals instead of microphone timing in order to determine direction of audio. Sound from car\u2019s movement, such as servo motors and wheels, were causing our robot to turn randomly. Created wings out of cardboard which lifted and spread out the left/right microphones away from the wheels. Random/sudden loud noises from the environment made the car turn in wrong directions, even when originally was moving correctly towards audio source. Averaged the audio signals of each microphone over the last few ticks using a buffer in order to reduce impact of outlier noises. Required tuning, as a small buffer would not remove outliers as effectively while a large buffer reduced reaction time of robot\u2019s movement when direction of audio actually changed What did not work Original plan was to use the time delay between when microphones head a noise over a sound threshold in order to calculate angle of sound. Problem with that is the Jetson Nano is running Linux, and due to background processes and overhead, it is not precise enough to identify the timing needed for this method to work when the microphones are this close together. This may have been possible with a real-time system such as an Arduino Another method was using real-time localized sound by performing beamforming using microphones in array, but we were not certain if we had enough time to implement and debug this method in time (received the microphones on Saturday) as it was significantly more complex than the other options. Next Steps (If we had more time) Car follows specific audio signals (eg. someone\u2019s voice) rather than based on volume, would help filter interference with background noises. Function based on sound difference between microphones to get precise steering angles. Current only steers forward, full left, full right. More accurate movement with our backwards direction Minimize unwanted noise coming from either surroundings or the vehicle.","title":"Team 4"},{"location":"win23team4/#team-4-final-project-report","text":"","title":"Team 4 Final Project Report"},{"location":"win23team4/#members-vasanth-senthil-ece-eddy-rodas-limamae-lingpeng-mengece","text":"","title":"Members: Vasanth Senthil (ECE), Eddy Rodas Lima(MAE), Lingpeng Meng(ECE)"},{"location":"win23team4/#physical-setup","text":"","title":"Physical Setup"},{"location":"win23team4/#initial-goals","text":"","title":"Initial Goals"},{"location":"win23team4/#objective","text":"Make our RoboCar follow sound using sound localization from multiple microphones.","title":"Objective"},{"location":"win23team4/#must-haves","text":"Car is able to determine approximate direction of an audio source Car moves in towards audio source once direction of audio is determined","title":"Must Haves"},{"location":"win23team4/#nice-to-haves","text":"Car follows specific audio signals (eg. someone\u2019s voice) rather than based on volume Accurate movement towards source","title":"Nice to Haves"},{"location":"win23team4/#accomplishments","text":"Researched and experimented with different methods of sound localization, such as using time of arrival delay between microphones Used the pyaudio library to collect streams of microphone data from each of the three microphone, and processed this data in order to tell direction real-time based on sound level Used the pyvesc library to create a custom movement file that allows us to easily move the RoboCar based on provided angles and throttle until specified conditions are met The microphone processing file called upon the movement functions after determining current direction. We also spread the left and right microphones to minimize the noise created by the car\u2019s movement, which would influence the accuracy of direction calculations.","title":"Accomplishments"},{"location":"win23team4/#demo-videos","text":"Static Source Left Static Source Right Moving Source Front Moving Source Back Moving Source Further Away","title":"Demo Videos"},{"location":"win23team4/#issues-faced","text":"Issue Solution Original idea of using time delay between microphones was not possible due to jetson limitations Decided to use volume of sound signals instead of microphone timing in order to determine direction of audio. Sound from car\u2019s movement, such as servo motors and wheels, were causing our robot to turn randomly. Created wings out of cardboard which lifted and spread out the left/right microphones away from the wheels. Random/sudden loud noises from the environment made the car turn in wrong directions, even when originally was moving correctly towards audio source. Averaged the audio signals of each microphone over the last few ticks using a buffer in order to reduce impact of outlier noises. Required tuning, as a small buffer would not remove outliers as effectively while a large buffer reduced reaction time of robot\u2019s movement when direction of audio actually changed","title":"Issues Faced"},{"location":"win23team4/#what-did-not-work","text":"Original plan was to use the time delay between when microphones head a noise over a sound threshold in order to calculate angle of sound. Problem with that is the Jetson Nano is running Linux, and due to background processes and overhead, it is not precise enough to identify the timing needed for this method to work when the microphones are this close together. This may have been possible with a real-time system such as an Arduino Another method was using real-time localized sound by performing beamforming using microphones in array, but we were not certain if we had enough time to implement and debug this method in time (received the microphones on Saturday) as it was significantly more complex than the other options.","title":"What did not work"},{"location":"win23team4/#next-steps-if-we-had-more-time","text":"Car follows specific audio signals (eg. someone\u2019s voice) rather than based on volume, would help filter interference with background noises. Function based on sound difference between microphones to get precise steering angles. Current only steers forward, full left, full right. More accurate movement with our backwards direction Minimize unwanted noise coming from either surroundings or the vehicle.","title":"Next Steps (If we had more time)"},{"location":"win23team5/","text":"Final Project Repository for Team 5 of the 2023 Winter Class MAE ECE 148 at UCSD Our Final Project has one main objective, which is inspired by a pet dog that plays fetch. Our goal is to design a robot that can identify a green ball, like a tennis ball, locate it, move towards it, pick it up, and return back to its initial location. We achieved this using an OpenCV-based vision system to recognize the ball and Pyvesc to control the car's movements. We also designed a claw mechanism to pick up the ball when it's within range and a servo to move the ball into the claw. In summary, our project demonstrates the capabilities of an autonomous robot that can navigate an environment, recognize objects, and perform tasks like fetching. With further improvements, this type of robot could have many potential applications in various industries.","title":"Team 5"},{"location":"win23team5/#final-project-repository-for-team-5-of-the-2023-winter-class-mae-ece-148-at-ucsd","text":"Our Final Project has one main objective, which is inspired by a pet dog that plays fetch. Our goal is to design a robot that can identify a green ball, like a tennis ball, locate it, move towards it, pick it up, and return back to its initial location. We achieved this using an OpenCV-based vision system to recognize the ball and Pyvesc to control the car's movements. We also designed a claw mechanism to pick up the ball when it's within range and a servo to move the ball into the claw. In summary, our project demonstrates the capabilities of an autonomous robot that can navigate an environment, recognize objects, and perform tasks like fetching. With further improvements, this type of robot could have many potential applications in various industries.","title":"Final Project Repository for Team 5 of the 2023 Winter Class MAE ECE 148 at UCSD"},{"location":"win23team6/","text":"MAE/ECE 148 Winter 2023 at UCSD TEAM 6 Our project uses the OAK-D camera, a roboflow YOLO model, PyVESC module, and an Arduino-powered camera mount to get our car to scan its surroundings until it finds a basketball and drive until it is within about 0.5 m of the ball. Car Assembly Vehicle Body Camera Mount Tech Stack RoboflowOak Module We used roboflow to train a ball detection model and host the model. We, then, made API calls to hosted model to retrieve predictions on frame captures from the OAK-D camera. Once a ball is found, we wrote a script to calculate the angle between the center of the bounding box drawn around the detected ball and the centerline of the camera (which by default is the center of the frame). PyVESC Module We used the pyvesc module to set our servo's angle once a detection has been made. The steering angle is proportional to the calculated angle. Once the steering is set, we increase throttle for about half a second and then stop the motor to make another detection. We then loop over these steps until the ball is within 0.5 m of the frame. Our stopping condition was for the width of the bounding box of the ball to be a certain ratio of the total frame width. The ratio is hardcoded based on fine-tuning to get the car to stop at about 0.5 m. Arduino Board We used an arduino nano to control the camera mount. The camera mount can rotate horizontally (yaw-equivalent) within a range of 180 degrees. And it can move up and down (pitch-equivalent) within a range of 90 degrees. This is used to move the camera around so it can scan the surroundings for a ball (in case the ball is not in frame). Motorized Camera Mount We designed a camera mount that is actuated by 2 servos, one controls the camera's pitch angle and the other controls the camera's yaw angle. The mount elevates the camera 5 inches amove the vehicle's mounting plate. It allows the camera to turn and scan for the target ball. https://user-images.githubusercontent.com/58583277/227646168-1071f237-de95-4f92-ad65-a90ee5fe2b01.mp4 How To Run The Code One can run python run.py from inside the Jetson Nano mounted on their car. This will load the model and also detect the motor and begin the purported task of finding a basketball. If no basketball is found, it will remain stationary. The 148remote/ folder contains a cool arduino program for proof of concept. It moves the camera mount through its full range of motion in a rhythmic fashion. Vehicle In Action Click Here For Video Future Improvements We can use the Jetson to control the servo motors through the Arduino. We can account for the yaw angle of the camera mount and add that to the steering, so that the car can steer toward targets that is not in the field of view of the camera when the camera is pointing straight forward. We can also improve the precision of the ball-recognition model by using more pictures of the ball to train the model. Team 6: Wall-E (used to be Cyclops) Saathvik Dirisala (Data Science) Victor Chen (Computer Engineering) Yang Song (Mechanical Engineering)","title":"Team 6"},{"location":"win23team6/#maeece-148-winter-2023-at-ucsd","text":"","title":"MAE/ECE 148 Winter 2023 at UCSD"},{"location":"win23team6/#team-6","text":"Our project uses the OAK-D camera, a roboflow YOLO model, PyVESC module, and an Arduino-powered camera mount to get our car to scan its surroundings until it finds a basketball and drive until it is within about 0.5 m of the ball.","title":"TEAM 6"},{"location":"win23team6/#car-assembly","text":"","title":"Car Assembly"},{"location":"win23team6/#vehicle-body","text":"","title":"Vehicle Body"},{"location":"win23team6/#camera-mount","text":"","title":"Camera Mount"},{"location":"win23team6/#tech-stack","text":"","title":"Tech Stack"},{"location":"win23team6/#roboflowoak-module","text":"We used roboflow to train a ball detection model and host the model. We, then, made API calls to hosted model to retrieve predictions on frame captures from the OAK-D camera. Once a ball is found, we wrote a script to calculate the angle between the center of the bounding box drawn around the detected ball and the centerline of the camera (which by default is the center of the frame).","title":"RoboflowOak Module"},{"location":"win23team6/#pyvesc-module","text":"We used the pyvesc module to set our servo's angle once a detection has been made. The steering angle is proportional to the calculated angle. Once the steering is set, we increase throttle for about half a second and then stop the motor to make another detection. We then loop over these steps until the ball is within 0.5 m of the frame. Our stopping condition was for the width of the bounding box of the ball to be a certain ratio of the total frame width. The ratio is hardcoded based on fine-tuning to get the car to stop at about 0.5 m.","title":"PyVESC Module"},{"location":"win23team6/#arduino-board","text":"We used an arduino nano to control the camera mount. The camera mount can rotate horizontally (yaw-equivalent) within a range of 180 degrees. And it can move up and down (pitch-equivalent) within a range of 90 degrees. This is used to move the camera around so it can scan the surroundings for a ball (in case the ball is not in frame).","title":"Arduino Board"},{"location":"win23team6/#motorized-camera-mount","text":"We designed a camera mount that is actuated by 2 servos, one controls the camera's pitch angle and the other controls the camera's yaw angle. The mount elevates the camera 5 inches amove the vehicle's mounting plate. It allows the camera to turn and scan for the target ball. https://user-images.githubusercontent.com/58583277/227646168-1071f237-de95-4f92-ad65-a90ee5fe2b01.mp4","title":"Motorized Camera Mount"},{"location":"win23team6/#how-to-run-the-code","text":"One can run python run.py from inside the Jetson Nano mounted on their car. This will load the model and also detect the motor and begin the purported task of finding a basketball. If no basketball is found, it will remain stationary. The 148remote/ folder contains a cool arduino program for proof of concept. It moves the camera mount through its full range of motion in a rhythmic fashion.","title":"How To Run The Code"},{"location":"win23team6/#vehicle-in-action","text":"Click Here For Video","title":"Vehicle In Action"},{"location":"win23team6/#future-improvements","text":"We can use the Jetson to control the servo motors through the Arduino. We can account for the yaw angle of the camera mount and add that to the steering, so that the car can steer toward targets that is not in the field of view of the camera when the camera is pointing straight forward. We can also improve the precision of the ball-recognition model by using more pictures of the ball to train the model.","title":"Future Improvements"},{"location":"win23team6/#team-6-wall-e-used-to-be-cyclops","text":"Saathvik Dirisala (Data Science) Victor Chen (Computer Engineering) Yang Song (Mechanical Engineering)","title":"Team 6: Wall-E (used to be Cyclops)"},{"location":"win23team7/","text":"UCSD ECE/MAE-148 2023 Winter Team 7 Team Members Francisco Downey (BENG), Jonathan Xiong (ECE), Nicholas Preston (MAE), Karthik Srinivasan (MAE) Final Project Overview For our final project, we made our car drive from point A to B, given starting and ending GPS points. Assembled Car Design LIDAR was set in the front of the car. This was an easy decision for the team since we cared for varying obstacles crossing the points that comprise the path from Point A to Point B. Essentially, it was only important to care for obstacles that come into the front of the moving car. GNSS was secure near the center of the car with the antenna placed high and toward the rear. DonkeyCar - 3 Autonomous Laps https://user-images.githubusercontent.com/103704890/227807530-35ed2ea5-2bc0-4b8b-983d-ca6bed659390.mp4 ROS2 Line Following - 3 Autonomous Laps https://user-images.githubusercontent.com/103704890/227801950-dfd60ddd-300e-4af8-9878-c62338184269.mp4 ROS2 Left Lane - 3 Autonomous Laps https://user-images.githubusercontent.com/103704890/227804039-c1aafb7a-8bf6-4f86-89cf-1fa21c7ea5d2.mp4 GPS - 3 Autonomous Laps https://user-images.githubusercontent.com/103704890/227804055-d9c3ccce-ef8d-427d-a6b6-e1db12eba440.mp4 Important to note for the final project, many of the configurations that were found to work in the GPS 3 autonomous laps were used for the final project. The GPS points making up the path were 0.55 meters apart. The nature of the csv points used in the final project matched the one used for this assignment. This allowed the project to move faster as the configurations did work out. See section Algorithmic Design of Directing Car from GPS point A to B. Final Project Plan: Go from point A to B with object detection. Overview Originally, we were going to have LIDAR detect objects in front of the car so the car can see what it needs to go around. However, we did not have enough time to see how to use LIDAR, since there was no assignment with it and not enough time at end of quarter given rain. We, however, got quite experienced with the GPS functionality of the car. Using the GPS modules, we were able to direct the car using a path of car-readble GPS coordinates. Algorithmic Design of Directing Car from GPS point A to B By the end of the quarter, we wrote a program, AtoB.py, which requires two sets of GPS coordinates as inputs. This program generates a .csv file containing a path of GPS coordinates about .55 meters apart from point A to B. These generated points latitude longitude formatted and relative to the base station antenna. The inputted absolute (planet's) GPS coordinates, thus, needed to be translated to these relative coordinates and converted to rectangular from polar positions. It took some testing to increase the precision of the translation as we did not know the exact conversion constants. Demonstration https://user-images.githubusercontent.com/103704890/227807009-ec59e649-c068-4543-9dba-9ddb16ea8ee5.mp4","title":"Team 7"},{"location":"win23team7/#ucsd-ecemae-148-2023-winter-team-7","text":"","title":"UCSD ECE/MAE-148 2023 Winter Team 7"},{"location":"win23team7/#team-members","text":"Francisco Downey (BENG), Jonathan Xiong (ECE), Nicholas Preston (MAE), Karthik Srinivasan (MAE)","title":"Team Members"},{"location":"win23team7/#final-project-overview","text":"For our final project, we made our car drive from point A to B, given starting and ending GPS points.","title":"Final Project Overview"},{"location":"win23team7/#assembled-car-design","text":"LIDAR was set in the front of the car. This was an easy decision for the team since we cared for varying obstacles crossing the points that comprise the path from Point A to Point B. Essentially, it was only important to care for obstacles that come into the front of the moving car. GNSS was secure near the center of the car with the antenna placed high and toward the rear.","title":"Assembled Car Design"},{"location":"win23team7/#donkeycar-3-autonomous-laps","text":"https://user-images.githubusercontent.com/103704890/227807530-35ed2ea5-2bc0-4b8b-983d-ca6bed659390.mp4","title":"DonkeyCar - 3 Autonomous Laps"},{"location":"win23team7/#ros2-line-following-3-autonomous-laps","text":"https://user-images.githubusercontent.com/103704890/227801950-dfd60ddd-300e-4af8-9878-c62338184269.mp4","title":"ROS2 Line Following - 3 Autonomous Laps"},{"location":"win23team7/#ros2-left-lane-3-autonomous-laps","text":"https://user-images.githubusercontent.com/103704890/227804039-c1aafb7a-8bf6-4f86-89cf-1fa21c7ea5d2.mp4","title":"ROS2 Left Lane - 3 Autonomous Laps"},{"location":"win23team7/#gps-3-autonomous-laps","text":"https://user-images.githubusercontent.com/103704890/227804055-d9c3ccce-ef8d-427d-a6b6-e1db12eba440.mp4 Important to note for the final project, many of the configurations that were found to work in the GPS 3 autonomous laps were used for the final project. The GPS points making up the path were 0.55 meters apart. The nature of the csv points used in the final project matched the one used for this assignment. This allowed the project to move faster as the configurations did work out. See section Algorithmic Design of Directing Car from GPS point A to B.","title":"GPS - 3 Autonomous Laps"},{"location":"win23team7/#final-project","text":"Plan: Go from point A to B with object detection. Overview Originally, we were going to have LIDAR detect objects in front of the car so the car can see what it needs to go around. However, we did not have enough time to see how to use LIDAR, since there was no assignment with it and not enough time at end of quarter given rain. We, however, got quite experienced with the GPS functionality of the car. Using the GPS modules, we were able to direct the car using a path of car-readble GPS coordinates. Algorithmic Design of Directing Car from GPS point A to B By the end of the quarter, we wrote a program, AtoB.py, which requires two sets of GPS coordinates as inputs. This program generates a .csv file containing a path of GPS coordinates about .55 meters apart from point A to B. These generated points latitude longitude formatted and relative to the base station antenna. The inputted absolute (planet's) GPS coordinates, thus, needed to be translated to these relative coordinates and converted to rectangular from polar positions. It took some testing to increase the precision of the translation as we did not know the exact conversion constants. Demonstration https://user-images.githubusercontent.com/103704890/227807009-ec59e649-c068-4543-9dba-9ddb16ea8ee5.mp4","title":"Final Project"},{"location":"win23team8/","text":"Team 8 Final Project Proposal Team Members - Youssef Georgy | Electrical & Computer Engineering - Rizzi Galibut | Mechanical & Aerospace Engineering - Shuhang Xu | Computer Science - Kavin Raj | Cognitive Science w/ Emphasis in Machine Learning Such a lovely team!! Project Overall A waiter-bot that takes visual input from the camera, navigates autonomously to different specified locations (i.e., tables) and then back to the starting point. Use image-detection via camera to give robocar a location or GPS coordinates to navigate to, then use GPS data to plot path there and avoid any obstacles in the way. The robocar will be able to take any location given (provided it\u2019s in range of the network connection) and determine how to get there Physical Setup Gantt Chart Demonstration Using DepthAI for text recognition Accomplished: - Used DepthAI to enable the camera to detect numbers which are associated with different tables (e.g., 001, 002, etc.) and different CSV files - Originally started by looking at OpenCV and Tesseract for OCR - These are not SpatialAI platforms so accomplishing what we were trying to do would be much harder - Default code provided in DepthAI library launched windows that displayed video stream and words detected, which worked when directly connected to camera through host computer but running code through Jetson would require a container to launch these windows - Needed to find a way to disable them and have camera run in the background Default code also rewrote the variable that contained the decoded text each time it detected something - Had to rewrite and remove sections of the code to stop detection once certain prompts are given - Light conditions really mattered when showing prompt to camera - Worked better during the day and when shown prompt on a backlit-screen (with white background) What did't work as expected: - Camera could read \u201c001\u201d but not \u201c1\u201d, etc., so we decided to use a set of numbers instead - Number recognition is much more accurate than word recognition so we decided to use numbers as the prompt Using GPS to record different paths GPS navigation code is based on the USCD donkeycar GPS library We are trying to make it stay in auto-pilot mode by default and reset the origin in the beginning Depend on what text is detected with DepthAI, make it move following the pre-recorded path When it moves back to the origin, stop and start detecting next text Desired but not accomplished Include the ability to restart the process once the waiter-bot returned to the starting point without having to manually run the script again Have waiter-bot stay at the table for a certain amount of time before returning to the starting point Incorporate the LiDAR so the waiter-bot can avoid obstacles (e.g., students walking past) while traveling to tables Could also be used to detect when the waiter-bot reaches the table and ensure it doesn\u2019t crash into it Have controller inputs programmed in so the waiter-bot can be truly autonomous. Currently still requires human input","title":"Team 8"},{"location":"win23team8/#team-8-final-project-proposal","text":"","title":"Team 8 Final Project Proposal"},{"location":"win23team8/#team-members","text":"- Youssef Georgy | Electrical & Computer Engineering - Rizzi Galibut | Mechanical & Aerospace Engineering - Shuhang Xu | Computer Science - Kavin Raj | Cognitive Science w/ Emphasis in Machine Learning Such a lovely team!!","title":"Team Members"},{"location":"win23team8/#project-overall","text":"A waiter-bot that takes visual input from the camera, navigates autonomously to different specified locations (i.e., tables) and then back to the starting point. Use image-detection via camera to give robocar a location or GPS coordinates to navigate to, then use GPS data to plot path there and avoid any obstacles in the way. The robocar will be able to take any location given (provided it\u2019s in range of the network connection) and determine how to get there","title":"Project Overall"},{"location":"win23team8/#physical-setup","text":"","title":"Physical Setup"},{"location":"win23team8/#gantt-chart","text":"","title":"Gantt Chart"},{"location":"win23team8/#demonstration","text":"","title":"Demonstration"},{"location":"win23team8/#using-depthai-for-text-recognition","text":"Accomplished: - Used DepthAI to enable the camera to detect numbers which are associated with different tables (e.g., 001, 002, etc.) and different CSV files - Originally started by looking at OpenCV and Tesseract for OCR - These are not SpatialAI platforms so accomplishing what we were trying to do would be much harder - Default code provided in DepthAI library launched windows that displayed video stream and words detected, which worked when directly connected to camera through host computer but running code through Jetson would require a container to launch these windows - Needed to find a way to disable them and have camera run in the background Default code also rewrote the variable that contained the decoded text each time it detected something - Had to rewrite and remove sections of the code to stop detection once certain prompts are given - Light conditions really mattered when showing prompt to camera - Worked better during the day and when shown prompt on a backlit-screen (with white background) What did't work as expected: - Camera could read \u201c001\u201d but not \u201c1\u201d, etc., so we decided to use a set of numbers instead - Number recognition is much more accurate than word recognition so we decided to use numbers as the prompt","title":"Using DepthAI for text recognition"},{"location":"win23team8/#using-gps-to-record-different-paths","text":"GPS navigation code is based on the USCD donkeycar GPS library We are trying to make it stay in auto-pilot mode by default and reset the origin in the beginning Depend on what text is detected with DepthAI, make it move following the pre-recorded path When it moves back to the origin, stop and start detecting next text","title":"Using GPS to record different paths"},{"location":"win23team8/#desired-but-not-accomplished","text":"Include the ability to restart the process once the waiter-bot returned to the starting point without having to manually run the script again Have waiter-bot stay at the table for a certain amount of time before returning to the starting point Incorporate the LiDAR so the waiter-bot can avoid obstacles (e.g., students walking past) while traveling to tables Could also be used to detect when the waiter-bot reaches the table and ensure it doesn\u2019t crash into it Have controller inputs programmed in so the waiter-bot can be truly autonomous. Currently still requires human input","title":"Desired but not accomplished"},{"location":"win23team9/","text":"ECE/MAE 148 Winter 2023 Team 9 JetBuddy Indoor Delivery Bot based on DepthAI, OpenCV and LiDAR Table of Contents Team Members Hardware and Schematics Parts Schematics Final Project Abstract Part 1: Human Detection and Following with Depthai and PyVesc Part 2: Stopping Mechanism with Lidar Part 3: Facial Recognition Part 4: Spatial Detection with DepthAI Reflection Challenges Potential Improvements Presentation Files Reference Team members Ben Zhang (ECE) Joseph Katona (ECE) Yichen Yang (ECE) Zijian Wang (MAE) Hardware Parts Full Assembly Mounting Plate Jetson Case Camera LiDAR Mount Final Project Delivery Box Schematics Wire Diagram Final Project Abstract This project aims to develop a delivery system for our robocar that can detect and follow humans while also incorporating a stopping mechanism to prevent collisions. Additionally, the robot will utilize facial recognition to identify individuals and personalize interactions. Part 1: Human Detection and Following with Depthai and PyVesc The OAKD camera will be used to detect and track humans in the robot's vicinity. The PyVesc motor controllers will then be used to move the robot in the direction of the detected human. Required Components Tiny-Yolov3 model integrated in DepthAi for object detection PyVesc Python package for robocar control Algorithm Workflow Use Tiny-Yolov3 to detect the bounding box of the person in the OAKD camera's field of view. Determine the position of the person by finding the central line of the bounding box, and denote the x-axis value as x0. Calculate the error between the central line of the frame (416x416 pixels), e = x - x0. Calculate the steering value using the formula: v = (Kp * e) / 416 + 0.5, where Kp = 1. Use PyVesc to control steering by calling vesc.set_servo(v). Additional Settings Use vesc.set_rpm() to run the car once it detects people. The steering value is sampled at a rate of 5Hz to prevent frequent drifting. Part 2: Stopping Mechanism with Lidar The Lidar sensor will be used to detect obstacles in the robot's path. If an obstacle is detected, the robot will stop moving and wait for the obstacle to clear before continuing on its path. The LiDAR on this robot aim to Detect anything that is in a close range If the position is too clase, the robot will stop to avoid collision The robot will back up after it stop for a while and still detect obstacle is close Transform raw binary data from LiDAR to numerical data through BinASCII library How to read LiDAR? Each measurement data point of LiDAR is consists of a distance value of 2 bytes and a confidence of 1 byte We transform this data through chopping it to bytes and translate it. We get the angle by getting the start angle and end angle. Putting all the distance into a list and it will stop the car if there\u2019s an object within certain distance that LiDAR detected. Part 3: Facial Recognition The robot will be equipped with a facial recognition system, using a webcam, that will allow it to identify individuals and personalize interactions. Once it recognizes the right person, the delivery box will open. The facial recognition software uses a simple python import of facial_recognition. In the facial_recognition library all we do is use openCV to capture images for the frames and use facial_recognitions \"matching\" function to to add a box around the persons face. In our case when this value is detected over an interval then a true value is then sent to the box to open. Part 4: Spatial Detection with DepthAI Utilizing Depthai's pipeline system we take their spatial location pipeline to simply calculate the distance of individual from the camera. The Object detection pipeline detects a person and creates a bounded box, then with the x and y coordinates from the bounded box we can pinpoint where we want the camera to point. After these coordinates are gathered the z location is stored in a circular list. This is because the bounded box and tracker of object distance aren't always in sync so some erroneous values are given. Once we have around 50 samples then we take the average to get a good idea of what the distance of the person from the car is. Finally we utilize pyvescs set_rpm() features to give out a more smooth acceleration system. So, basically if you're far away the robot will speed up and slow down as it moves closer to you. Get more info on Spatial Depth here Gantt Chart Demonstrations The Video might not show up, please go to img folder for full demo. Your browser does not support HTML video. Reflection Challenges Getting everything to work together Different libraries working together and all send signals to PyVESC Everything worked fine on a local machine but when running on the Jetson, crashes would occur Scope of the original idea Mapping the path for future references using SLAM Depth ai pipeline caused crashes X-Link Problem(Serial bus issues) Translate raw LiDAR output to data we need Making the car look smooth Better algorithm to adjust speed(rpm) Potential Improvements Implement all the features together flawlessly Currently cannot run together good due to delay from different components Get the locking mechanism working Locking mechanism to make sure the right receiver get the package LiDar also scans the path for future path planning Trying to find a person if it cannot detect anything Maybe try different frameworks since we can use different libraries without limitation in ROS or donkeycar Presentations Project Proposal & Progress Report Final Presntation Reference We would like to give special thanks to: Professor Jack Silberman TA Moises Lopez TA Kishore Nukala All The teams that helped us on the way","title":"Team 9"},{"location":"win23team9/#team-members","text":"Ben Zhang (ECE) Joseph Katona (ECE) Yichen Yang (ECE) Zijian Wang (MAE)","title":"Team members"},{"location":"win23team9/#hardware","text":"","title":"Hardware"},{"location":"win23team9/#parts","text":"","title":"Parts"},{"location":"win23team9/#full-assembly","text":"","title":"Full Assembly"},{"location":"win23team9/#mounting-plate","text":"","title":"Mounting Plate"},{"location":"win23team9/#jetson-case","text":"","title":"Jetson Case"},{"location":"win23team9/#camera-lidar-mount","text":"","title":"Camera LiDAR Mount"},{"location":"win23team9/#final-project-delivery-box","text":"","title":"Final Project Delivery Box"},{"location":"win23team9/#schematics","text":"","title":"Schematics"},{"location":"win23team9/#wire-diagram","text":"","title":"Wire Diagram"},{"location":"win23team9/#final-project","text":"","title":"Final Project"},{"location":"win23team9/#abstract","text":"This project aims to develop a delivery system for our robocar that can detect and follow humans while also incorporating a stopping mechanism to prevent collisions. Additionally, the robot will utilize facial recognition to identify individuals and personalize interactions.","title":"Abstract"},{"location":"win23team9/#part-1-human-detection-and-following-with-depthai-and-pyvesc","text":"The OAKD camera will be used to detect and track humans in the robot's vicinity. The PyVesc motor controllers will then be used to move the robot in the direction of the detected human.","title":"Part 1: Human Detection and Following with Depthai and PyVesc"},{"location":"win23team9/#required-components","text":"Tiny-Yolov3 model integrated in DepthAi for object detection PyVesc Python package for robocar control","title":"Required Components"},{"location":"win23team9/#algorithm-workflow","text":"Use Tiny-Yolov3 to detect the bounding box of the person in the OAKD camera's field of view. Determine the position of the person by finding the central line of the bounding box, and denote the x-axis value as x0. Calculate the error between the central line of the frame (416x416 pixels), e = x - x0. Calculate the steering value using the formula: v = (Kp * e) / 416 + 0.5, where Kp = 1. Use PyVesc to control steering by calling vesc.set_servo(v).","title":"Algorithm Workflow"},{"location":"win23team9/#additional-settings","text":"Use vesc.set_rpm() to run the car once it detects people. The steering value is sampled at a rate of 5Hz to prevent frequent drifting.","title":"Additional Settings"},{"location":"win23team9/#part-2-stopping-mechanism-with-lidar","text":"The Lidar sensor will be used to detect obstacles in the robot's path. If an obstacle is detected, the robot will stop moving and wait for the obstacle to clear before continuing on its path.","title":"Part 2: Stopping Mechanism with Lidar"},{"location":"win23team9/#the-lidar-on-this-robot-aim-to","text":"Detect anything that is in a close range If the position is too clase, the robot will stop to avoid collision The robot will back up after it stop for a while and still detect obstacle is close Transform raw binary data from LiDAR to numerical data through BinASCII library","title":"The LiDAR on this robot aim to"},{"location":"win23team9/#how-to-read-lidar","text":"Each measurement data point of LiDAR is consists of a distance value of 2 bytes and a confidence of 1 byte We transform this data through chopping it to bytes and translate it. We get the angle by getting the start angle and end angle. Putting all the distance into a list and it will stop the car if there\u2019s an object within certain distance that LiDAR detected.","title":"How to read LiDAR?"},{"location":"win23team9/#part-3-facial-recognition","text":"The robot will be equipped with a facial recognition system, using a webcam, that will allow it to identify individuals and personalize interactions. Once it recognizes the right person, the delivery box will open. The facial recognition software uses a simple python import of facial_recognition. In the facial_recognition library all we do is use openCV to capture images for the frames and use facial_recognitions \"matching\" function to to add a box around the persons face. In our case when this value is detected over an interval then a true value is then sent to the box to open.","title":"Part 3: Facial Recognition"},{"location":"win23team9/#part-4-spatial-detection-with-depthai","text":"Utilizing Depthai's pipeline system we take their spatial location pipeline to simply calculate the distance of individual from the camera. The Object detection pipeline detects a person and creates a bounded box, then with the x and y coordinates from the bounded box we can pinpoint where we want the camera to point. After these coordinates are gathered the z location is stored in a circular list. This is because the bounded box and tracker of object distance aren't always in sync so some erroneous values are given. Once we have around 50 samples then we take the average to get a good idea of what the distance of the person from the car is. Finally we utilize pyvescs set_rpm() features to give out a more smooth acceleration system. So, basically if you're far away the robot will speed up and slow down as it moves closer to you. Get more info on Spatial Depth here","title":"Part 4: Spatial Detection with DepthAI"},{"location":"win23team9/#gantt-chart","text":"","title":"Gantt Chart"},{"location":"win23team9/#demonstrations","text":"The Video might not show up, please go to img folder for full demo. Your browser does not support HTML video.","title":"Demonstrations"},{"location":"win23team9/#reflection","text":"","title":"Reflection"},{"location":"win23team9/#challenges","text":"Getting everything to work together Different libraries working together and all send signals to PyVESC Everything worked fine on a local machine but when running on the Jetson, crashes would occur Scope of the original idea Mapping the path for future references using SLAM Depth ai pipeline caused crashes X-Link Problem(Serial bus issues) Translate raw LiDAR output to data we need Making the car look smooth Better algorithm to adjust speed(rpm)","title":"Challenges"},{"location":"win23team9/#potential-improvements","text":"Implement all the features together flawlessly Currently cannot run together good due to delay from different components Get the locking mechanism working Locking mechanism to make sure the right receiver get the package LiDar also scans the path for future path planning Trying to find a person if it cannot detect anything Maybe try different frameworks since we can use different libraries without limitation in ROS or donkeycar","title":"Potential Improvements"},{"location":"win23team9/#presentations","text":"Project Proposal & Progress Report Final Presntation","title":"Presentations"},{"location":"win23team9/#reference","text":"We would like to give special thanks to: Professor Jack Silberman TA Moises Lopez TA Kishore Nukala All The teams that helped us on the way","title":"Reference"},{"location":"win23team12/","text":"ECE 148 Winter 2023 Team 12 Final Project Team members Jake Kindley (ECE) Yiteng Zhao (ECE) Noah Jones (MAE) Overview We want to create a sorter bot similar to warehouse bots that picks up a package, follow the path with certain color and delivers it to designated dropoff location based on the labels on that package. We plan to put AR tags as labels on the package, and each AR tag is mapped to an id associated with either the color of the lane our bot should follow or stop action when it reaches the designated dropoff zone. At dropoff zone, the bot will perform a series of maneuver and return to the starting point. Robot Design & Implementation Software Our code is running on ROS2 and is modified based on the provided lane following code from class. The following flowchart shows the original relationship between each component in the provided lane following code from class: We added a node responsible for detecting AR tag, read states from AR tag, and changing lane detector's behavior. In our new node, we have defined two types of AR tags: Type 1: Declares the lane color our bot should follow Type 2: Stop signal that indicates the bot to drop the package The default behavior when no AR tag is being detected is following blue lane until a type 1 tag is detected. Hardware We designed a bracket as package holder that snaps on the front bumper of the car and holds one package: Showcase Assembled Robots Final Project Demo Remarks Our video demonstrated our bot's capability of detecting AR tag, selecting the corresponding lane color, following path to dropoff zone, dropping off package in front of stop sign, and return to the starting point. Potential improvements for this project includes adding obstacle avoidance, redesigning the package holder to hold the package above ground, adjusting camera position for better view angle of the lane, and adding capability to navigate through multiple junctions.","title":"Team 12"},{"location":"win23team12/#ece-148-winter-2023-team-12-final-project","text":"","title":"ECE 148 Winter 2023 Team 12 Final Project"},{"location":"win23team12/#team-members","text":"Jake Kindley (ECE) Yiteng Zhao (ECE) Noah Jones (MAE)","title":"Team members"},{"location":"win23team12/#overview","text":"We want to create a sorter bot similar to warehouse bots that picks up a package, follow the path with certain color and delivers it to designated dropoff location based on the labels on that package. We plan to put AR tags as labels on the package, and each AR tag is mapped to an id associated with either the color of the lane our bot should follow or stop action when it reaches the designated dropoff zone. At dropoff zone, the bot will perform a series of maneuver and return to the starting point.","title":"Overview"},{"location":"win23team12/#robot-design-implementation","text":"","title":"Robot Design &amp; Implementation"},{"location":"win23team12/#software","text":"Our code is running on ROS2 and is modified based on the provided lane following code from class. The following flowchart shows the original relationship between each component in the provided lane following code from class: We added a node responsible for detecting AR tag, read states from AR tag, and changing lane detector's behavior. In our new node, we have defined two types of AR tags: Type 1: Declares the lane color our bot should follow Type 2: Stop signal that indicates the bot to drop the package The default behavior when no AR tag is being detected is following blue lane until a type 1 tag is detected.","title":"Software"},{"location":"win23team12/#hardware","text":"We designed a bracket as package holder that snaps on the front bumper of the car and holds one package:","title":"Hardware"},{"location":"win23team12/#showcase","text":"","title":"Showcase"},{"location":"win23team12/#assembled-robots","text":"","title":"Assembled Robots"},{"location":"win23team12/#final-project-demo","text":"","title":"Final Project Demo"},{"location":"win23team12/#remarks","text":"Our video demonstrated our bot's capability of detecting AR tag, selecting the corresponding lane color, following path to dropoff zone, dropping off package in front of stop sign, and return to the starting point. Potential improvements for this project includes adding obstacle avoidance, redesigning the package holder to hold the package above ground, adjusting camera position for better view angle of the lane, and adding capability to navigate through multiple junctions.","title":"Remarks"},{"location":"win23team13/","text":"Final Project: Robot Mapping Team 13: Girish, Muhammad, Andy, and Van ECE MAE 148, Winter 2023 Welcome to the project report for Team 13! This page contains a report of all the progress we made throughout this busy and fun quarter, including our final project. Team 13's assembled RC Car with the lidar placed at the front. Table of Contents Final Project: Robot Mapping - Team 13: Girish, Muhammad, Andy, and Van - ECE MAE 148, Winter 2023 Table of Contents The Team Final Project Abstract Hardware Setup Base Plate Camera Mount Jetson Nano Case Electronics Circuit Diagram Software Documentation Autonomous Laps Acknowledgements Credit and References The Team Girish Krishnan [ LinkedIn ] Muhammad Bintang Gemilang Andy Zhang Zhengyu (Van) Huang Electrical Engineering Mechanical Engineering Electrical Engineering Computer Engineering Final Project Abstract Our final project was themed around mapping an unknown environment . Our project involved the following tasks. What we promised [\u2714] To implement SLAM (Simultaneous Localization and Mapping) using a lidar. This effectively creates a map of the environment around the robot, showing the locations of all objects present. [\u2714] To display the map generated from SLAM in real-time using a web application. The challenges faced during the project were: Integrating the web application for live previewing (HTML/CSS/JS) with the Python code needed to run SLAM. Avoiding delays in the updating map. The accomplishments of the project were: We were able to achieve a decent visualization that updates over time as the robot is driven around The visualization/map can be saved easily for tasks such as path planning. Final Presentation Link to Final Presentation Link to video showing real-time mapping Weekly Update Presentations Project Proposal Week 8 Week 9 Week 10 Gantt Chart Hardware Setup 3D Printing: Camera Mount, Jetson Nano Case, GPS (GNSS) Case. Laser Cutting: Base plate to mount electronics and other components. Parts List Traxxas Chassis with steering servo and sensored brushless DC motor Jetson Nano WiFi adapter 64 GB Micro SD Card Adapter/reader for Micro SD Card Logitech F710 controller OAK-D Lite Camera LD06 Lidar VESC Anti-spark switch with power switch DC-DC Converter 4-cell LiPo battery Battery voltage checker/alarm DC Barrel Connector XT60, XT30, MR60 connectors Additional Parts used for testing/debugging Car stand USB-C to USB-A cable Micro USB to USB cable 5V, 4A power supply for Jetson Nano Base Plate All measurements shown above are in millimeters (mm) Our base plate was laser cut on a thick acrylic sheet. The circular hole at the end of the base plate is meant to hold the power on/off button. The long holes in the side of the plate are meant for wires to easily pass to and from the bottom of the plate. Camera Mount Camera Holder Base for attachment to base plate The two parts of the camera mount shown above were screwed together. The angle of the camera was carefully chosen (facing downward approximately 10 degrees from the vertical) so that the road ahead is clearly visible. This is essential for accurate results in OpenCV/ROS2 autonomous laps. One of our older camera mount designs is shown below. This camera mount consists of three parts: one base for attachment to the base plate, one middle piece to connect the base and the camera, and the camera holder. This camera mount design allows you to rotate the camera up and down. However, it is important that the rotating hinge is screwed securely so that the hinge doesn't wobble out while the robot does autonomous laps! Jetson Nano Case Credit to flyattack from Thingiverse, see: https://www.thingiverse.com/thing:3532828 This case is excellent because it is robust and doesn't break easily, unlike most common Jetson Nano cases. Electronics Circuit Diagram Note: some of these components and connections will vary depending on the exact components you have - check the component specifications carefully. Software Documentation To install all the necessary Python modules needed, run the following on the Jetson Nano. pip install -r requirements.txt For our final project, we implemented a real-time visualization system for the Hector SLAM algorithm implemented using the lidar sensor. The base code for the SLAM algorithm is accessible in the Docker container provided to us in class, and the code for the real-time implementation is present in the slam_gui folder of this repository. The SLAM real-time visualization GUI that we built has the following features: A web application whose routes are made using FastAPI in Python. Uvicorn is used to run the web server. HTML and JS to update the map in real-time The HTML and JS is interfaced with Python, ROS1, ROS2 and ROSBridge, so that the data collected is displayed on the web app. The interfacing process is difficult to implement directly in Python, so we use subprocessing to call relevant bash scripts that handle the processes in ROS1 and ROS2. These subprocesses are made to run in parallel using threading in Python. To run the visualizer, first open up a docker container containing the ucsd_robocar ROS packages. Run the following: cd slam_gui python slam_map.py This sets up the web app running on the Jetson Nano (although the app could potentially be run on any device, provided it can communicate with the Jetson Nano using the relevant ROS topics). Opening up the web app on http://localhost:8000 reveals the GUI showing the results of SLAM in real-time. The code in slam_map.py can be adjusted to fine-tune the time-delay that occurs as the map updates. Additional Scope for the Final Project Although SLAM is useful for mapping an unknown environment, it can be useful to integrate GPS data with SLAM to provide better location accuracy. To implement this in Python, we created the folder gps_slam that contains starter code with lidar, PyVESC, and GPS implementation and a basic SLAM algorithm with the Kalman filter (implemented using the filterpy library in Python). This additional, nice-to-have part of the project hasn't been tested out yet, but we plan to get it working soon. Autonomous Laps As part of the class deliverables and as preparation for the final project, here are our autonomous laps videos: Donkey Sim Local Computer: https://youtu.be/lXEStSEVikQ GPU training: https://youtu.be/4_BzKP9-XAQ External Server: https://youtu.be/Yvo1yqRJhX4 Physical Robot DonkeyCar: https://youtu.be/bPUSS2g0Ves Lane detection using OpenCV + ROS2: https://youtu.be/omcDCBSrl2I Inner lane: https://youtu.be/9hN8HUlGcas Outer lane: https://youtu.be/nXZNPscVlX0 GPS: https://youtu.be/Y3I9AWW1R6o Acknowledgements Thanks Prof. Jack Silberman and TAs Moises Lopez and Kishore Nukala for an awesome quarter! See you in DSC 178 next quarter, professor Jack ;) Credit and References Jetson Nano Case Design: https://www.thingiverse.com/thing:3532828 Lidar (LD06) Python Tutorial: https://github.com/henjin0/LIDAR_LD06_python_loder PyVESC: https://github.com/LiamBindle/PyVESC SLAM tutorial, Dominic Nightingale. https://gitlab.com/ucsd_robocar/ucsd_robocar_nav1_pkg/-/tree/master/","title":"Team 13"},{"location":"win23team13/#final-project-robot-mapping","text":"","title":"Final Project: Robot Mapping"},{"location":"win23team13/#team-13-girish-muhammad-andy-and-van","text":"","title":"Team 13: Girish, Muhammad, Andy, and Van"},{"location":"win23team13/#ece-mae-148-winter-2023","text":"Welcome to the project report for Team 13! This page contains a report of all the progress we made throughout this busy and fun quarter, including our final project. Team 13's assembled RC Car with the lidar placed at the front.","title":"ECE MAE 148, Winter 2023"},{"location":"win23team13/#table-of-contents","text":"Final Project: Robot Mapping - Team 13: Girish, Muhammad, Andy, and Van - ECE MAE 148, Winter 2023 Table of Contents The Team Final Project Abstract Hardware Setup Base Plate Camera Mount Jetson Nano Case Electronics Circuit Diagram Software Documentation Autonomous Laps Acknowledgements Credit and References","title":"Table of Contents"},{"location":"win23team13/#the-team","text":"Girish Krishnan [ LinkedIn ] Muhammad Bintang Gemilang Andy Zhang Zhengyu (Van) Huang Electrical Engineering Mechanical Engineering Electrical Engineering Computer Engineering","title":"The Team"},{"location":"win23team13/#final-project-abstract","text":"Our final project was themed around mapping an unknown environment . Our project involved the following tasks. What we promised [\u2714] To implement SLAM (Simultaneous Localization and Mapping) using a lidar. This effectively creates a map of the environment around the robot, showing the locations of all objects present. [\u2714] To display the map generated from SLAM in real-time using a web application. The challenges faced during the project were: Integrating the web application for live previewing (HTML/CSS/JS) with the Python code needed to run SLAM. Avoiding delays in the updating map. The accomplishments of the project were: We were able to achieve a decent visualization that updates over time as the robot is driven around The visualization/map can be saved easily for tasks such as path planning. Final Presentation Link to Final Presentation Link to video showing real-time mapping Weekly Update Presentations Project Proposal Week 8 Week 9 Week 10 Gantt Chart","title":"Final Project Abstract"},{"location":"win23team13/#hardware-setup","text":"3D Printing: Camera Mount, Jetson Nano Case, GPS (GNSS) Case. Laser Cutting: Base plate to mount electronics and other components. Parts List Traxxas Chassis with steering servo and sensored brushless DC motor Jetson Nano WiFi adapter 64 GB Micro SD Card Adapter/reader for Micro SD Card Logitech F710 controller OAK-D Lite Camera LD06 Lidar VESC Anti-spark switch with power switch DC-DC Converter 4-cell LiPo battery Battery voltage checker/alarm DC Barrel Connector XT60, XT30, MR60 connectors Additional Parts used for testing/debugging Car stand USB-C to USB-A cable Micro USB to USB cable 5V, 4A power supply for Jetson Nano","title":"Hardware Setup"},{"location":"win23team13/#base-plate","text":"All measurements shown above are in millimeters (mm) Our base plate was laser cut on a thick acrylic sheet. The circular hole at the end of the base plate is meant to hold the power on/off button. The long holes in the side of the plate are meant for wires to easily pass to and from the bottom of the plate.","title":"Base Plate"},{"location":"win23team13/#camera-mount","text":"Camera Holder Base for attachment to base plate The two parts of the camera mount shown above were screwed together. The angle of the camera was carefully chosen (facing downward approximately 10 degrees from the vertical) so that the road ahead is clearly visible. This is essential for accurate results in OpenCV/ROS2 autonomous laps. One of our older camera mount designs is shown below. This camera mount consists of three parts: one base for attachment to the base plate, one middle piece to connect the base and the camera, and the camera holder. This camera mount design allows you to rotate the camera up and down. However, it is important that the rotating hinge is screwed securely so that the hinge doesn't wobble out while the robot does autonomous laps!","title":"Camera Mount"},{"location":"win23team13/#jetson-nano-case","text":"Credit to flyattack from Thingiverse, see: https://www.thingiverse.com/thing:3532828 This case is excellent because it is robust and doesn't break easily, unlike most common Jetson Nano cases.","title":"Jetson Nano Case"},{"location":"win23team13/#electronics-circuit-diagram","text":"Note: some of these components and connections will vary depending on the exact components you have - check the component specifications carefully.","title":"Electronics Circuit Diagram"},{"location":"win23team13/#software-documentation","text":"To install all the necessary Python modules needed, run the following on the Jetson Nano. pip install -r requirements.txt For our final project, we implemented a real-time visualization system for the Hector SLAM algorithm implemented using the lidar sensor. The base code for the SLAM algorithm is accessible in the Docker container provided to us in class, and the code for the real-time implementation is present in the slam_gui folder of this repository. The SLAM real-time visualization GUI that we built has the following features: A web application whose routes are made using FastAPI in Python. Uvicorn is used to run the web server. HTML and JS to update the map in real-time The HTML and JS is interfaced with Python, ROS1, ROS2 and ROSBridge, so that the data collected is displayed on the web app. The interfacing process is difficult to implement directly in Python, so we use subprocessing to call relevant bash scripts that handle the processes in ROS1 and ROS2. These subprocesses are made to run in parallel using threading in Python. To run the visualizer, first open up a docker container containing the ucsd_robocar ROS packages. Run the following: cd slam_gui python slam_map.py This sets up the web app running on the Jetson Nano (although the app could potentially be run on any device, provided it can communicate with the Jetson Nano using the relevant ROS topics). Opening up the web app on http://localhost:8000 reveals the GUI showing the results of SLAM in real-time. The code in slam_map.py can be adjusted to fine-tune the time-delay that occurs as the map updates. Additional Scope for the Final Project Although SLAM is useful for mapping an unknown environment, it can be useful to integrate GPS data with SLAM to provide better location accuracy. To implement this in Python, we created the folder gps_slam that contains starter code with lidar, PyVESC, and GPS implementation and a basic SLAM algorithm with the Kalman filter (implemented using the filterpy library in Python). This additional, nice-to-have part of the project hasn't been tested out yet, but we plan to get it working soon.","title":"Software Documentation"},{"location":"win23team13/#autonomous-laps","text":"As part of the class deliverables and as preparation for the final project, here are our autonomous laps videos: Donkey Sim Local Computer: https://youtu.be/lXEStSEVikQ GPU training: https://youtu.be/4_BzKP9-XAQ External Server: https://youtu.be/Yvo1yqRJhX4 Physical Robot DonkeyCar: https://youtu.be/bPUSS2g0Ves Lane detection using OpenCV + ROS2: https://youtu.be/omcDCBSrl2I Inner lane: https://youtu.be/9hN8HUlGcas Outer lane: https://youtu.be/nXZNPscVlX0 GPS: https://youtu.be/Y3I9AWW1R6o","title":"Autonomous Laps"},{"location":"win23team13/#acknowledgements","text":"Thanks Prof. Jack Silberman and TAs Moises Lopez and Kishore Nukala for an awesome quarter! See you in DSC 178 next quarter, professor Jack ;)","title":"Acknowledgements"},{"location":"win23team13/#credit-and-references","text":"Jetson Nano Case Design: https://www.thingiverse.com/thing:3532828 Lidar (LD06) Python Tutorial: https://github.com/henjin0/LIDAR_LD06_python_loder PyVESC: https://github.com/LiamBindle/PyVESC SLAM tutorial, Dominic Nightingale. https://gitlab.com/ucsd_robocar/ucsd_robocar_nav1_pkg/-/tree/master/","title":"Credit and References"},{"location":"win23team14/","text":"ECE - MAE 148 Team 14 Winter 2023 Repository Project Goal: We used the OAK-D camera to run object detection (within the camera) and track different traffic details (common signs, speed limits, etc.) Software and Hardware Description: The OAK-D and depthAI are AI-enabled stereo cameras that allow for depth perception and 3D mapping. They are powerful tools for computer vision applications, such as object detection and tracking. The depthAI is a board that enables faster processing of images by offloading the computational workload from the main processor to dedicated hardware. YOLO (You Only Look Once) is a real-time object detection system that is capable of detecting objects in an image or video feed. It is a popular deep learning model that is used in many computer vision applications, including self-driving cars and robotics. PyVesc is a Python library for controlling VESC-based motor controllers. The VESC is an open-source ESC (Electronic Speed Controller) that is widely used in DIY robotics projects. PyVesc allows for easy communication with the VESC and provides an interface for setting motor parameters and reading sensor data. Project Overview: We first used the OAK-D and depthAI to detect stop signs in the robot's field of view. Then, we executed the deep learning model YOLO to process the camera feed and identify the stop sign(text detection can be another method to achieve the same function). Once the stop sign is detected, we implemented PyVesc to send a command to the motor controller to stop the robot and started to set up the OAK-D and depthAI cameras by installing the necessary software libraries. YOLO is capable of detecting multiple objects simultaneously, so we needed to filter out the stop sign from other detected objects. However, we needed a blob converter to take different data types and convert them into a Binary Large Object (BLOB) that could fit in our code. Finally, once the stop sign is detected, we accessed PyVesc to send a command to the motor controller to stop the robot. In summary, the integration of OAK-D, depthAI, YOLO, and PyVesc allows for efficient and accurate stop sign detection and safe stopping of the robot. This implementation can be further customized and optimized for specific robotic platforms and use cases. Final Projet Presentation: https://docs.google.com/presentation/d/1BTMwfktHvDzfzYd6oSnHeaQTEBbtYg8wEMnqoWkamHE/edit?usp=sharing Final Project Video: https://drive.google.com/file/d/1OnO5qWczQbH_aVrgKAtejwLMw6-fFSRW/view?usp=share_link Team Members: Anish Kulkarni, Manuel Abitia, Zizhe Zhang. Special Thanks to: Professor Silberman, Kishore, Moises, and Freddy C. the Robot.","title":"Team 14"},{"location":"win23team15/","text":"Final Project Repository for Team 15 of the 2023 Winter Class MAE ECE 148 at UCSD Our Final Project uses the AI controlled autonomous vehicle developed in early course sections to implement a driving protocol based on hand signals. To do this, we utilize the GPS-tracking and following code developed/given in class, and combined it with the DepthAI gesture recognition software pack. Our idea developed from our interest in the OAK-D Lite camera\u2019s stereo vision system and ability to run DepthAI within the camera for processing. To use both of these functions, we chose to run a hand detection program that uses Google Mediapipe to combine these features in a unique project that no one on our team had tried before. Using this bleeding edge hardware was really interesting and showed the potential in the given components and also in general the viability of gesture-based control even in relatively low-cost projects. Below are examples of how our hand detection tracker will recognize our gestures Car Physical Setup Our car setup used a large piece of acrylic to connect across the RC car strut towers to support all of our electronics. The acrylic had two grooves along the entire length that were 3 inches apart, allowing us to reconfigure our electronics layout as the class progressed. We knew we would be given different devices through the length of the class, so this modular setup gave us the ability to adapt to them quickly rather than redesigning everytime. We also made heave use of 3D printing, which further cemented the viability of our acrylic rail mount system, since we just had to design a mount that could take mounting screws three inches apart. This enabled us to quickly and with low effort include different configurations and components. We then further used 3D-printed components to functionalize parts of our design, such as a height-adjustable camera mount, and a lidar mount employing the same functionality. Our camera setup was originally a rigid mount on the front of the car, but as we tested our initial Donkey Car laps on the outdoor track we recognized the need for adjusting our angle to detect the lines better. This led to our tall hinging mount that gave us better viewing angles that we could set up within seconds for testing. Software In total, we used three different software packages either from discord, or developed in the course of the class, those beeing the depthai software pack, the d5 GPS control system and the donkeycar Software. depthai software pack To detect hand gestures, we use the Luxonis DepthAI Software on the Luxonis OAK-D stereo-vision camera. This software pack brings plenty of functionality, from simple hand tracking, two two-handed interactions, all the way to gesture recognition. We then modified the existing codebase to suit our needs, including specialized code to regognize a set of largely custom, non-included hand gestures: - Thumbs-up gesture to activate driving - Held up flat hand as a stop signal - different number of fingers (with the thumb not pointing outwards) changes the speed in a four level control scheme - pointing the index finger with thumb outstreched left or right to change direction of steering d5 GPS-control In the d5 subdirectory, we used the donkeycar interfaces to program a simple GPS training and following routine to generate a path for the car to follow. This part of the project is still partly in development, as currently only the speed can be varied with hand signals. We largely reused tech generated and tought to us in the course of the class, providing a nice framework on which to test our system. DonkeyCar Software We use the preconfigured DonkeyCar software package to facilitate control and interfacing of the Jetson nano embedded system with the rest of the RC car. We implemented a special interrupt in the signal chain to be able to pass in different speed values, which are first stored by the modified DepthAI software pack into the file finalproject/comm.txt as a simple string command corresponding to the recognized hand sign. which is then read into the DonkeyCar VESC control subroutine to change the throttle values dynamically. Operation One can either run the depthai software on its own with the VESC class implemented right in the file demo_bdf.py by just executing it with all lines commented in, or, if it is desired to just utilize the throttle values, comment out the VESC related code, run the demo_bpf.py and then simultaneaously run the d5 donkeycar code with ./python manage.py drive. Then, steering will be controlled by the GPS following algorithm, while the speed is controlled via the detected hand signals. The follwing youtube videos show the basic functionality of our project, and how it interacts with the complex drivetrain of the car. Basic Command Gesture Throttle Changing Values Team 15: Boba Team Reinwei Bai Manu Mittal Reisandy Lamdjani Moritz Wagner","title":"Team 15"},{"location":"win23team15/#final-project-repository-for-team-15-of-the-2023-winter-class-mae-ece-148-at-ucsd","text":"Our Final Project uses the AI controlled autonomous vehicle developed in early course sections to implement a driving protocol based on hand signals. To do this, we utilize the GPS-tracking and following code developed/given in class, and combined it with the DepthAI gesture recognition software pack. Our idea developed from our interest in the OAK-D Lite camera\u2019s stereo vision system and ability to run DepthAI within the camera for processing. To use both of these functions, we chose to run a hand detection program that uses Google Mediapipe to combine these features in a unique project that no one on our team had tried before. Using this bleeding edge hardware was really interesting and showed the potential in the given components and also in general the viability of gesture-based control even in relatively low-cost projects. Below are examples of how our hand detection tracker will recognize our gestures","title":"Final Project Repository for Team 15 of the 2023 Winter Class MAE ECE 148 at UCSD"},{"location":"win23team15/#car-physical-setup","text":"Our car setup used a large piece of acrylic to connect across the RC car strut towers to support all of our electronics. The acrylic had two grooves along the entire length that were 3 inches apart, allowing us to reconfigure our electronics layout as the class progressed. We knew we would be given different devices through the length of the class, so this modular setup gave us the ability to adapt to them quickly rather than redesigning everytime. We also made heave use of 3D printing, which further cemented the viability of our acrylic rail mount system, since we just had to design a mount that could take mounting screws three inches apart. This enabled us to quickly and with low effort include different configurations and components. We then further used 3D-printed components to functionalize parts of our design, such as a height-adjustable camera mount, and a lidar mount employing the same functionality. Our camera setup was originally a rigid mount on the front of the car, but as we tested our initial Donkey Car laps on the outdoor track we recognized the need for adjusting our angle to detect the lines better. This led to our tall hinging mount that gave us better viewing angles that we could set up within seconds for testing.","title":"Car Physical Setup"},{"location":"win23team15/#software","text":"In total, we used three different software packages either from discord, or developed in the course of the class, those beeing the depthai software pack, the d5 GPS control system and the donkeycar Software.","title":"Software"},{"location":"win23team15/#depthai-software-pack","text":"To detect hand gestures, we use the Luxonis DepthAI Software on the Luxonis OAK-D stereo-vision camera. This software pack brings plenty of functionality, from simple hand tracking, two two-handed interactions, all the way to gesture recognition. We then modified the existing codebase to suit our needs, including specialized code to regognize a set of largely custom, non-included hand gestures: - Thumbs-up gesture to activate driving - Held up flat hand as a stop signal - different number of fingers (with the thumb not pointing outwards) changes the speed in a four level control scheme - pointing the index finger with thumb outstreched left or right to change direction of steering","title":"depthai software pack"},{"location":"win23team15/#d5-gps-control","text":"In the d5 subdirectory, we used the donkeycar interfaces to program a simple GPS training and following routine to generate a path for the car to follow. This part of the project is still partly in development, as currently only the speed can be varied with hand signals. We largely reused tech generated and tought to us in the course of the class, providing a nice framework on which to test our system.","title":"d5 GPS-control"},{"location":"win23team15/#donkeycar-software","text":"We use the preconfigured DonkeyCar software package to facilitate control and interfacing of the Jetson nano embedded system with the rest of the RC car. We implemented a special interrupt in the signal chain to be able to pass in different speed values, which are first stored by the modified DepthAI software pack into the file finalproject/comm.txt as a simple string command corresponding to the recognized hand sign. which is then read into the DonkeyCar VESC control subroutine to change the throttle values dynamically.","title":"DonkeyCar Software"},{"location":"win23team15/#operation","text":"One can either run the depthai software on its own with the VESC class implemented right in the file demo_bdf.py by just executing it with all lines commented in, or, if it is desired to just utilize the throttle values, comment out the VESC related code, run the demo_bpf.py and then simultaneaously run the d5 donkeycar code with ./python manage.py drive. Then, steering will be controlled by the GPS following algorithm, while the speed is controlled via the detected hand signals. The follwing youtube videos show the basic functionality of our project, and how it interacts with the complex drivetrain of the car. Basic Command Gesture Throttle Changing Values","title":"Operation"},{"location":"win23team15/#team-15-boba-team","text":"Reinwei Bai Manu Mittal Reisandy Lamdjani Moritz Wagner","title":"Team 15: Boba Team"}]}